{-# LANGUAGE GeneralizedNewtypeDeriving, FlexibleInstances #-}

module Maps.DataType (
	Contextable,
	DataSet(..),
	Context(..),
	StvOrdinal,
	StvNominal,
	StvRatio,
	RetHue,
	hue,
	RetLightless,
	lightless,
	RetSize,
	size',
	generateDataset,
	generateRelationset,
	dsToNominal,
	dsTransform,
	compositeDs
	) where

import Data.Colour.Palette.BrewerSet
import qualified Data.Map.Lazy as M
import qualified Data.List as L

-- | DATATYPE MODULE -------------------------------------------------------------------------------------------------
-- ...................................................................................................................
-- ___________________________________________________________________________________________________________________

-- |Synonims for the different kinds of data, and the code. This helps to mantain the code more legible.
type StvNominal = String

type StvOrdinal = Int 

type StvRatio = Double

type Code = String

-- |The polymorphic algebraic datatype DataSet has two constructors:
--  EntitySet refers to data about entities, in this case regions. It contains a parameter v, which is a hash map with 
--  the data ordered by codes y a context
--  RelationSet refers to data about relations, in this case links or flows. It contains a parameter rv, which is a list
--  of triples containing the connected nodes and the value. It also has a context parameter.
data DataSet a = EntitySet {v :: M.Map Code a , c :: Context} | RelationSet {rv :: [(Code, Code, a)] , c :: Context}

-- |The Context algebraic datatype provides information relevan to the data contained in the dataset, such as the maximum,
--  the nominal values... It has a constructor for every kind of data, namely Nominal, Ordinal and Ratio, and a predefined
--  brewerset.
data Context =  NominalContext {values :: [StvNominal], brewerset :: ColorCat} | 
				OrdinalContext {mx :: StvOrdinal, mn :: StvOrdinal, step :: StvOrdinal, brewerset :: ColorCat} |
				RatioContext {rmx :: StvRatio, rmn :: StvRatio, brewerset :: ColorCat}  
				deriving (Eq)  

-- |The Type Classes for the retinal variables. If a type implements a retinal type class that means that it is 
--  appropriate representate it through it. For example a nominal type implements hue but not size.

-- |class RetHue : Interface for the retinal variable hue, also referred as color in the literature. 
--  it contains a method hue, receiving a context and a (Maybe) a value for which it will return a color (or a 
--  default one if it receives nothing)
--  the method hue' receives an extra parameter explicitely indicating the range of values, which is calculated 
--  automatically in the previous one.
class RetHue a where
	hue :: Context -> Maybe a -> Kolor
	hue' :: Int -> Context -> Maybe a -> Kolor
 
-- |class RetSize : Interface for the retinal variable size. 
--  it contains a method size, receiving a context and a (Maybe) a value for which it will return a size (or a 
--  default one if it receives nothing)
--  the method size' receives an extra parameter explicitely indicating the range of values, which is calculated 
--  automatically in the previous one.
class RetSize a where
	--  size applies by default a scale 1-2, which means that for the minimum value the size won't increase, and for the maximum 
    --       value it will be the double.
	size :: Context -> Maybe a -> Double
	--  size' gets as the first parameter the scale that will be applied.
	size' :: (Double, Double) -> Context -> Maybe a -> Double

-- |class RetLightless : Interface for the retinal variable ligthless or opacity. 
--  it contains a method lightless, receiving a context and a (Maybe) a value for which it will return a size (or a 
--  default one if it receives nothing)
class RetLightless a where
	lightless :: Context -> Maybe a -> Double

-- |class Contextable : Type class for all the types which can be inserted in a dataset and, therefore, for which a 
--  context can be created.
--  it contains a method 
class Contextable a where
	-- |autoContext : (abstract) Function that generates a predefined context for a dataset
	--  Note that in some cases we must know those characteristics in advance, and we may want to ensure not to accept invalid values
	--  or explore the fact that certain values never occur. In these cases, the context should be created manually or updated from the
	--  autogenerated one.
	autoContext :: DataSet a -> DataSet a
	-- |autoContext : Function that generates a predefined dataset from a list of tuples (Code, a), being a Contextable
	generateDataset :: [(Code, a)] -> DataSet a
	generateDataset list = autoContext EntitySet{v = M.fromList list}
	-- |autoContext : Function that generates a predefined dataset from a list of triples (Code, Code, a), being a Contextable
	generateRelationset :: [(Code, Code, a)] -> DataSet a
	generateRelationset list = autoContext RelationSet{rv = list}

-- |Contextable instance for StvNominal : The set of valid nominal values is assumed to be the list of distinct values on the dataset
instance Contextable StvNominal where
	autoContext ds@ EntitySet{v = list} = ds {c = defNominalContext {values = L.nub (M.elems list)}}
	autoContext rs@ RelationSet{rv = list} = rs {c = defNominalContext {values = L.nub [ a|(_,_,a)<-list] } }

-- |Contextable instance for StvOrdinal : The maximum and minimum values are assumed to be the max and min values on the dataset
instance Contextable StvOrdinal where
	autoContext ds@ EntitySet {v = list} = ds {c = defOrdinalContext {mx = L.maximum (M.elems list), mn = L.minimum (M.elems list)}}
	autoContext rs@ RelationSet{rv = list} = let sub = [ a|(_,_,a)<-list]
		in rs {c = defOrdinalContext {mx = L.maximum sub, mn = L.minimum sub}}

-- |Contextable instance for StvRatio : The maximum and minimum values are assumed to be the max and min values on the dataset
instance Contextable StvRatio where
	autoContext ds@ EntitySet {v = list} = ds {c = defRatioContext {rmx = L.maximum (M.elems list), rmn = L.minimum (M.elems list)}}
	autoContext rs@ RelationSet{rv = list} = let sub = [ a|(_,_,a)<-list]
		in rs {c = defRatioContext {rmx = L.maximum sub, rmn = L.minimum sub}}

-- |RetHue instance for StvNominal : Calculates the hue for a nominal value
instance RetHue StvNominal where
	hue ctx@NominalContext{values = vals} = hue' (length vals -1) ctx
	hue' _ _ Nothing = (brewerSet Greys 9) !! 0
	hue' size ctx (Just value) = 
		let 
			vals = values ctx
			index = ei (L.elemIndex value vals) 0
			bs = brewerset ctx
		in (brewerSet bs size) !! index

-- |RetHue instance for StvOrdinal : Calculates the hue for an ordinal value
instance RetHue StvOrdinal where
	hue = hue' 9
	hue' _ _ Nothing = (brewerSet Greys 9) !! 0
	hue' size ctx value = 
		let 
			index = round (scaleOrdinal (0, fromIntegral (size-1)) ctx value)
			bs = brewerset ctx
		in (brewerSet bs size) !! index

-- |RetHue instance for StvRatio : Calculates the hue for a rational value
instance RetHue StvRatio where
	hue = hue' 11
	hue' _ _ Nothing = (brewerSet Greys 9) !! 0
	hue' size ctx value = 
		let 
			index = round (scaleRatio (0, fromIntegral (size-1)) ctx value)
			bs = brewerset ctx
		in (brewerSet bs size) !! index

-- |RetLightless instance for StvOrdinal : Calculates the lightless for a ordinal value
instance RetLightless StvOrdinal where
	lightless = scaleOrdinal (0.5,1)

-- |RetLightless instance for StvRatio : Calculates the lightless for a rational value
instance RetLightless StvRatio where 
	lightless = scaleRatio (0.5,1)	

-- |RetSize instance for StvOrdinal : Calculates the size for a ordinal value. 
instance RetSize StvOrdinal where
	size = scaleOrdinal (1,2)
	size' = scaleOrdinal

-- |RetSize instance for StvRatio : Calculates the size for a rational value
instance RetSize StvRatio where
	size = scaleRatio (1,2)
	size' = scaleRatio

-- |Default values for the three different contexts. They contain default values and
--  appropriate brewersets for displaying information: different colores for nominal, 
--  color transition for ordinal and scale of intensity for ratio.
defNominalContext = NominalContext {values = [], brewerset = Dark2}
defOrdinalContext = OrdinalContext {mx = 100, mn = 0, step = 1, brewerset = YlGnBu}
defRatioContext = RatioContext {rmx = 100, rmn = 0, brewerset = PiYG}


-- |dsTransform : This function transforms a DataSet from one type to another. We provide
--  The original dataset and a function that maps values of the type a to values of the type
--  b. B has to be a Contectable type, that means, either StvNominal, StvOrdinal or StvRatio
--  at this point. 
dsTransform :: (Contextable b) => DataSet a -> (a -> b) -> DataSet b
dsTransform EntitySet{v=ds} f = let list = [ (k, f d)|(k, d) <- (M.toList ds)]
						in generateDataset list
dsTransform RelationSet{rv=ds} f = let list = [ (k, k2,f d)|(k, k2, d) <- ds]
						in generateRelationset list

-- |compositeDs : This function combines two datasets into one, through a provided function. 
--  We provide a function that receives one param of each dataset, and those two datasets.
--  C has to be a Contectable type, that means, either StvNominal, StvOrdinal or StvRatio
--  at this point. 
--  This function only works for a couple of EntitySets or a couple of RelationSets. If a mix
--  is provided, an empty Dataset will be returned.
compositeDs :: (Contextable c, Eq b) => (a -> b -> c) -> DataSet a -> DataSet b -> DataSet c
compositeDs f EntitySet{v=ds1} EntitySet{v=ds2} = let 
		nv a (Just b) = f a b
		list = [ (c, nv v v2) | (c, v) <- M.toList ds1, M.member c ds2, let v2 = M.lookup c ds2 ]
	in generateDataset list
compositeDs f RelationSet{rv=ds1} RelationSet{rv=ds2} = let 
		nv a (Just (_,_,b)) = f a b
		fnd c1 c2 = L.find(\(x1,x2,_)->x1==c1 && x2==c2) ds2 
		list = [ (c1, c2, nv v v2) | (c1, c2, v) <- ds1, fnd c1 c2 /= Nothing, let v2 = fnd c1 c2 ]
	in generateRelationset list
compositeDs f _ _ = generateDataset []

-- |dsToNominal : This function transforms a DataSet from one type to a Nominal. We provide
--  The original dataset and a function that maps values to Int, ans a set of possible values
dsToNominal :: DataSet a -> (a -> Int) -> [StvNominal] -> DataSet StvNominal
dsToNominal EntitySet{v=ds} f values = let list = [ (k, values !! (f d))|(k, d) <- (M.toList ds)]
						in EntitySet {v=M.fromList list, c= defNominalContext {values = values}}
dsToNominal RelationSet{rv=ds} f values = let list = [ (k, k2, values !! (f d))|(k, k2, d) <- ds]
						in RelationSet {rv=list, c= defNominalContext {values = values}}

-- |scaleRatio : Utils function to scale a rational value.
scaleRatio :: (StvRatio, StvRatio) -> Context -> Maybe StvRatio -> StvRatio
scaleRatio _ _ Nothing = 0.5 
scaleRatio (scmin, scmax) RatioContext {rmx=max, rmn=min} (Just value) = 
	let baseScale = (value - min) / (max - min)
	in baseScale * (scmax - scmin) + scmin

-- |scaleOrdinal : Utils function to scale a ordinal value.
scaleOrdinal :: (StvRatio, StvRatio) -> Context -> Maybe StvOrdinal -> StvRatio
scaleOrdinal _ _ Nothing = 0.5 
scaleOrdinal (scmin, scmax) OrdinalContext{mx=max, mn=min} (Just value) = 
	let 
		baseScale = fromIntegral (value - min) / fromIntegral (max - min)
	in baseScale * (scmax - scmin) + scmin

-- |lookupKolor : Utils function to relate a color with an index
--  receives a Maybe int and a list of colors. It returns either a default value in case of nothing or
--  the appropriate value of the brewerset otherwise.
lookupKolor :: Maybe Int -> [Kolor] -> Kolor
lookupKolor Nothing _ = (brewerSet Greys 9) !! 0 
lookupKolor (Just something) colors = colors !! something

-- |ei : Utils function to get either the value a from a @Just a@ or a default value if it's @Nothing@.
--  receives two arguments: Maybe a and a (the default value to return in case of Nothing)
ei :: Maybe a -> a -> a
ei (Just x) _ = x 
ei Nothing v = v
